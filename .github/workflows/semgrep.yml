name: Semgrep

on:
  push:
    branches: [ "main", "CI-CD" ]
  pull_request:
    branches: [ "main" ]
  schedule:
    - cron: '30 3 * * 4'
  workflow_dispatch:

permissions:
  contents: read
  security-events: write
  actions: read

jobs:
  semgrep:
    name: Semgrep SAST
    runs-on: ubuntu-latest
    env:
      # Mapeia o secret para checagem condicional
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Caminho A: usa Semgrep Cloud se houver token (policy, dashboards, etc.)
      - name: Run Semgrep (Cloud) with policy gate
        if: ${{ env.SEMGREP_APP_TOKEN != '' }}
        uses: returntocorp/semgrep-action@fcd5ab7459e8d91cb1777481980d1b18b4fc6735
        with:
          publishToken: ${{ secrets.SEMGREP_APP_TOKEN }}
          generateSarif: "1"
          # Opcional: force audit também em push (além de PR)
          # auditOn: "push,pull_request"

      # Caminho B: fallback local (sem token). Usa packs OWASP + Java + .semgrep.yml e falha em ERROR
      - name: Install Semgrep (fallback)
        if: ${{ env.SEMGREP_APP_TOKEN == '' }}
        run: pipx install semgrep

      - name: Run Semgrep (local) — OWASP + Java (gate em ERROR)
        if: ${{ env.SEMGREP_APP_TOKEN == '' }}
        run: |
          # Usa configs públicas e, se existir, suas regras locais
          CONFIGS="--config p/owasp-top-ten --config p/java"
          test -f .semgrep.yml && CONFIGS="$CONFIGS --config .semgrep.yml" || true
          semgrep $CONFIGS \
            --severity=ERROR --error \
            --sarif --output semgrep.sarif

      # Upload do SARIF (funciona para os dois caminhos)
      - name: Upload SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif

